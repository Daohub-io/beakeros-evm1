\documentclass[english,a4paper]{article}
\usepackage{lmodern}
\usepackage{float}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\usepackage{microtype}
\usepackage[unicode=true]{hyperref}
\usepackage[usenames,dvipsnames]{color}
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            %linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{listings}

\usepackage{longtable,booktabs}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines


% Redefines (sub)paragraphs to behave more like sections
\ifx\subsubsection\undefined\else
\let\oldparagraph\subsubsection
\renewcommand{\subsubsection}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

{\renewcommand{\arraystretch}{1.5}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\title{Beaker Specification}\label{beaker-specification}

\author{Jacob Payne \and Jake O'Shannessy \and Alexey Troitskiy}

\begin{document}

\maketitle

\begin{abstract}\label{abstract}

We describe a secure and extensible operating system for smart contracts. Using
a capability-based exokernel protocol, we can facilitate secure isolation,
perform upgrades in a secure and robust manner, and prevent privilege escalation
at any point in the development process. The protocol is intended to serve as an
open standard and building block upon which more advanced and tailored security
models can be built.

\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Kernel Storage}\label{kernel-storage}
This is a critical feature. \emph{All} data stored by the kernel is stored in a
region of \emph{storage} called \emph{kernel storage}. \emph{No} other data can
be stored in \emph{kernel storage}.

This kernel storage is defined as all storage locations within a certain storage
range. All values in kernel storage share the same storage key prefix. This
prefix is currently 0x00, and so currently includes all values in the interval
$[0\text{x}0000 \cdots 0000, 0\text{x}0100 \cdots 0000)$ (some zeros have been
elided for typographic reasons, but each values is 32 bytes).

\textbf{TODO:} This is currently defined using storage pages which we don't use anywhere
else. I think we should remove the concept of storage pages.

\section{Procedures}\label{procedures}
Data about procedure is store in 2 locations: the procedure table, and the
procedure heap. The procedure table is simply a managed, enumerable, and
iterable list of procedure keys (procedure key being something that identifies a
particular procedure). The data associated with a procedure, such as its
Ethereum address and its capabilities are stored on the procedure heap. Given a
procedure key, the data associated with a procedure can be located using that
key.

\subsection{Procedure Key}
Each procedure is defined by a procedure key. This key is a sequence of 24 8-bit
bytes. This is treated as a sequence of 192~bits in all cases.

The kernel itself treats the procedure keys as an opaque 192-bit value, however,
the capability system and some functions apply prefixes to these key value. For
example: capabilities that rely on procedure key values will often use a prefix
value to define a range of keys. This allows one to defined a hierarchy of
procedures, much like a directory structrue. See those capabilities for more
detail.

\subsection{Key Index}
Each procedure key included in the kernel is associated with a key index, which
identifies a procedure in the procedure table. This is not used anywhere except
the procedure table itself. It is 1-based, that is the first value is 1, and the
value 0 is a null value.

As shown below, the maximum number of procedures is $2^{24} - 1 = 16,777,215$,
therefore the maxium value of the key index is $16,777,215$, therefore the key
index lies in the range $\left[1,1677215\right]$.

\subsection{Procedure Table}\label{procedure-table}
The procedure table (or procedure list) is simply an array of storage values.
The first value is the length of this list, and the subsequent values are the
procedure keys of the list.

When a procedure is added to the kernel:

\begin{enumerate}
  \item The procedure data is added to the procedure heap (see
  Section~\ref{procedure-heap}).
  \item The procedure key is appended to the end of the array.
  \item The length value (the first value) is incremented by one.
\end{enumerate}

When a procedure is deleted from the kernel:

\begin{enumerate}
  \item If the procedure key is the same as the Entry Procedure Key, abort and
  throw an error.
  \item If the procedure key does not exist in the list, abort and throw an
  error.
  \item The length value is decremented by one.
  \item If the procedure being deleted is not the last in the list, the last in
  the list is copied to overwrite the key being deleted. This also accounts for
  the case of an empty list.
\end{enumerate}

It is important to note that none of these steps consider deletion (zeroing) of
data. This is optional for efficiency and can be performed any time after the
length value has been decremented.

The procedure table is stored using the key \texttt{0x5bac198c377b7d}, which is
the first 7 bytes of keccack256("keyPointer"). Along with the storage page
(which is prepended to this value) this creates a prefix of
\texttt{0x005bac198c377b7d}. The maximum number of keys held under this
configuration is $2^{24} - 1 = 16,777,215$ (1 is subtracted to account for the
length value occupying a single space). This is one less than the total number
of procedures that can be held by the kernel (which is $2^{24} = 16,777,216$).

\begin{verbatim}
  0x005bac198c377b7d + 24 more bytes
\end{verbatim}

\begin{table}[H]
  \caption{Procedure table.}
  \centering{}%
  \begin{tabular}{l|p{0.4\textwidth}}
    \hline
    Storage Location & Description\tabularnewline
    \hline
    \hline
    \texttt{0x005bac198c377b7d}     & length/number of procedures
      \tabularnewline
    \texttt{0x005bac198c377b7d} + keyIndex & procedure key/name: 24 bytes
      \tabularnewline
    ~~~$\vdots$ & capabilities in series \tabularnewline
    \texttt{0x005bac198c377b7d} + n & procedure key/name for procedure $n$
      \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsection{Procedure Heap}\label{procedure-heap}

\textbf{TODO:} This storage key value has been updated to use similar logic as
other locations. This is not reflected in the code.

Procedure data is stored using the key \texttt{0x85a94e7072} (which is the first
5 bytes of keccack256("procedurePointer")). The storage page (in this case
kernel storage) is prepended to this, and the procedure key is appended to this,
resulting in:

\begin{verbatim}
  0x0085a94e7072 + 24 bytes procedure key + 2 bytes data offset
\end{verbatim}

This leaves 2 bytes at the end of the storage location key. The values of these
2 bytes from \texttt{0x0000} to \texttt{0xffff} are reserved for the data
associated with this procedure. This allows for 65,536 storage key values. As
each key value can be associated with 32~bytes of data, this allows for
approximately 2~MB of data for each procedure, which is predominantly occupied
by the capabilities.

\includegraphics[width=\textwidth]{media/ProcedureKeyLocation.pdf}

\begin{table}[H]
  \caption{Procedure table.}
  \centering{}%
  % \begin{tabular}{>{\centering}p{0.25\textwidth}|>{\centering}p{0.475\textwidth}|>{\centering}p{0.2\textwidth}}
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Key Offset & Description\tabularnewline
    \hline
    \hline
    \texttt{0x0000}       & key: 24 bytes, aligned right in the 32 bytes, the
      given (\textbf{TODO:} this value is unnecessary, it is found in the
      addressed) name \tabularnewline
    \texttt{0x0001}       & keyIndex: 32 bytes, unsigned integer (\textbf{TODO:}
      I don't think this is necessary, we never use it, it is only useful to the
      procedure table itself)
      \tabularnewline
    \texttt{0x0002}       & address: 20 bytes, aligned right in the 32 bytes
      \tabularnewline
    \texttt{0x0003}       & numCaps: 2 bytes, aligned right in the 32 bytes
      \tabularnewline
    \texttt{0x0004}\ldots & capabilities in series \tabularnewline
    \hline
  \end{tabular}
\end{table}

\section{Capabilities}\label{capabilities}
\begin{table}[H]
  \caption{Capability.}
  \centering{}%
  % \begin{tabular}{>{\centering}p{0.25\textwidth}|>{\centering}p{0.475\textwidth}|>{\centering}p{0.2\textwidth}}
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Key Offset & Description\tabularnewline
    \hline
    \hline
    0x0       & CapSize: 2 bytes, aligned right in the 32 bytes, the given
      name \tabularnewline
    0x1       & CapType: 1 byte, aligned right in the 32 bytes \tabularnewline
    0x2       & key value \#1: 32 bytes \tabularnewline
    ~~~$\vdots$ & capabilities in series \tabularnewline
    CapSize & final key value \tabularnewline
    \hline
  \end{tabular}
\end{table}

\section{System Calls and Capabilities}
All system calls are transactions to the kernel. The transaction data is defined
as follows:

\begin{table}[H]
  \caption{System call structure.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & 1 byte, system call value \tabularnewline
    0x8 & The system call data as defined by each system call \tabularnewline
    ~~~$\vdots$ &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

If the transaction data is longer that specified by the system call format, the
additional data is simply ignored. \textbf{TODO:} We should consider throwing an
error on this.

System call numbers match capability numbers.

\begin{table}[H]
  \caption{System call and capability numbers.\label{syscall-numbers}}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Type Value & Description\tabularnewline
    \hline
    \hline
    0x0 & Null capability / noop \tabularnewline
    % 0x1 & The system call data as defined by each system call \tabularnewline
    % 0x2 & The system call data as defined by each system call \tabularnewline
    0x3 & Call Procedure \tabularnewline
    0x4 & Register Procedure \tabularnewline
    0x5 & Delete Procedure \tabularnewline
    0x6 & Set Entry Procedure \tabularnewline
    0x7 & Write \tabularnewline
    0x8 & Log \tabularnewline
    0x9 & Gas Send \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsection{Executing a System Call}
The running code will issue a transaction to the kernel by perfoming a
DELEGATECALL to the kernel with the transactions message data as both above and
in the definitons of each capability. The system call will be processed as
follows:

\begin{enumerate}
  \item The kernel will receive the transaction as defined by the EVM.
  \item The kernel will read the first byte of the transaction data as an
  unsigned 8-bit integer. This value is $s$.
  \item If $s$ is not one of the values listed in Table~\ref{syscall-numbers}
  then the kernel will revert the current transaction (i.e. the DELEGATECALL)
  and return the error code \texttt{SYSCALL\_NOEXIST} (error codes are defined
  in Section~\ref{errors}).
  \item If $s$ is 0, it will do nothing and return successfully.
  \item Otherwise the control will be passed to the code in the kernel
  corresponding to the $s$. For example if the $s = 0x4$, then the code for
  executing a Register Procedure syscall will be called.
  \item This code will execute and return whatever value it deems appropriate.
\end{enumerate}

\subsection{Return and Error Codes}\label{errors}
This section defines return and error codes for interacting with the kernel.
These values are returned by system calls \emph{only} in the event of a failure
of the kernel, in which case the DELEGATECALL will have been reverted. As a
result, these error codes are provided only when the kernel reverts, if the
DELEGATECALL returns normally, whatever is returned is determined by the
procedure being called. That is, the DELEGATECALL should leave a 0 on the stack.

The error code is always 8-bits, and may followed by additional data.

Therefore:

\begin{itemize}
  \item If 1 is left on the stack after the DELEGATECALL of a system call, then
  the system call succeeded, and whatever data was returned was returned by
  system call.
  \item If 0 is left on the stack after the DELEGATECALL of a system call, then
  the system call failed, and whatever data was returned is defined in the table
  below.
\end{itemize}

\begin{table}[H]
  \caption{Return and error codes.}
  \centering{}%
  \begin{tabular}{p{0.3\textwidth}|p{0.1\textwidth}|p{0.2\textwidth}|p{0.3\textwidth}}
    \hline
    Type & Value & Additional Data & Description\tabularnewline
    \hline
    \hline
    SYSCALL\_BADCAP  & 33 & None & Capability insufficient \tabularnewline
    SYSCALL\_NOGAS   & 44 & None & Procedure execution ran out of gas.
      \tabularnewline
    SYSCALL\_REVERT  & 55 & Returned data from procedure & The called
      procedure reverted. \tabularnewline
    SYSCALL\_FAIL    & 66 & System call specific error data & The system call
      failed for reasons specific to the system call. \tabularnewline
    SYSCALL\_NOEXIST & 111 & None & The syscall integer values is not a valid
      syscall as defined in Table \ref{syscall-numbers} \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsection{Capability Subsets}\label{cap-subsets}

Capability $B$ is a subset\footnote{$A$ subset, not a \emph{strict} or
\emph{proper} subset.} of Capability $A$, if everything that can be done using
Capability $B$ can be done using Capabilty $A$. The following rules apply:

\begin{itemize}
  \item $A$ is always a subset of itself. $A \subseteq A$
  \item Transitivity: $A \subseteq B \land B \subseteq C \implies A
  \subseteq C$
\end{itemize}

As the nature of each capability is different, the way subsets are defined is
different for each one. The following sections will define how subsets are
defined for each capability.

\subsection{Call System Call}

\subsubsection{System Call Format}
Type Value: 3

Data: Note that here the offset is from after system call type.

Note that here we could pack the data much more densely, but we don't in order
to err on the side of simplicity and stick as close as we can to 32-byte values.

\begin{table}[H]
  \caption{Call procedure system call format.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Prefix size, 1 bytes \tabularnewline
    0x21 & 8 unused bytes \tabularnewline
    0x28 & Procedure key, 24 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Format}
The capability format for the Call Procedure system call defines the a range of
procedure keys what the capability allows one to call. This is defined as a base
procedure key $b$ and a prefix $s$. Given this capability, a procedure may call
any procedure where the first $s$ bits of the key of that procedure key are the
same as the first $s$ bits of procedure key $b$.

\begin{table}[H]
  \caption{Call procedure capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x03 & The type of the capability \tabularnewline
    0x2 & -    & The prefix and base procedure key, the first byte is the prefix
                 size which is in the interval [0,24], bytes [0x1,0x7] are
                 unused and undefined, bytes [0x8,0x32] are the 24 bytes of the
                 base procedure key. \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\includegraphics[width=\textwidth]{media/ProcedureKeyBytes.pdf}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets. For the call capability a subset is capability which possesses the
ability to call no more procedures than the original.

The prefix size of a capability $C$ is given as $C_s$ and the base procedure key
$C_b$. Given a call procedure capability $A$ and a proposed subset $B$:
\begin{itemize}
  \item If the prefix size of $B$ is equal to or greater than $A$ (that is: $B_s
  \geq A_s$), and
  \item If the first $B_s$ bits of $B_b$ is equal to the first $A_s$ bits of
  $A_b$.
\end{itemize}

\subsubsection{Error Codes}
If the Call Procedure system call fails for any reason other than those
general system call failure conditions, the system call will return
\texttt{SYSCALL\_FAIL} (as definted in Section~\ref{errors}) followed by one of
the following codes.

\begin{table}[H]
  \caption{Return and error codes.}
  \centering{}%
  \begin{tabular}{l|l|p{0.2\textwidth}|p{0.2\textwidth}}
    \hline
    Type & Value & Additional Data & Description\tabularnewline
    \hline
    \hline
    CALL\_NOPROC  & 33 & None & The procedure key specified does not exit.
      \tabularnewline
    \hline
  \end{tabular}
\end{table}

\marginpar[Non-Normative]{\textbf{Non-Normative}}For example, if the Call
Procedure system call was executed with a procedure key that does not exist then
the DELEGATECALL will leave a 0 on the stack and return two bytes
(\texttt{0x6633}).

\subsection{Register Procedure System Call}

\subsubsection{System Call Format}
Type Value: 4

Data: min(96 bytes) max(96 bytes)

\begin{table}[H]
  \caption{Register procedure system call structure.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Procedure key; 24 bytes in 32 bytes \tabularnewline
    0x40 & Procedure address; 20 bytes in 32 bytes \tabularnewline
    ~~~$\vdots$ & Capabilities; A series of 32 byte values which correspond
    exactly to the keys as defined in Section~\ref{capabilities}. The length of
    this list is not provided. \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Format}
The capability format for the Register Procedure system call defines the a range
of procedure keys what the capability allows one to call. This is defined as a
base procedure key $b$ and a prefix $s$. Given this capability, a procedure may
call any procedure where the first $s$ bits of the key of that procedure key are
the same as the first $s$ bits of procedure key $b$.

\textbf{NB:} Register procedure also relies on all of the other capabilities
possessed by a procedure to determine what capabilities the new procedure will
have.

\begin{table}[H]
  \caption{Register procedure capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x04 & The type of the capability \tabularnewline
    0x2 & -    & The prefix and base procedure key, the first byte is the prefix
                 size which is in the interval [0,24], bytes [0x1,0x7] are
                 unused and undefined, bytes [0x8,0x32] are the 24 bytes of the
                 base procedure key. \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\includegraphics[width=\textwidth]{media/ProcedureKeyBytes.pdf}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets. For the register procedure capability a subset is capability which
possesses the ability to register no more procedures than the original.

The prefix size of a capability $C$ is given as $C_s$ and the base procedure key
$C_b$. Given a register procedure capability $A$ and a proposed subset $B$:
\begin{itemize}
  \item If the prefix size of $B$ is equal to or greater than $A$ (that is: $B_s
  \geq A_s$), and
  \item If the first $B_s$ bits of $B_b$ is equal to the first $A_s$ bits of
  $A_b$.
\end{itemize}

\subsubsection{Function}
This registers a new procedure which already exists as a contract at a certain
address, giving it a name an a list of capabilities. It does a number of things:

\begin{itemize}
  \item Validate the code at the given address to show that it complies with the
  requirements of procedure code as described in
  Section~\ref{bytecode-validation}.
  \item Add the procedure name to the procedure list.
  \item Store the specified capabilities with the procedure, but only if each of
  the capabilities is found to be a subset of one of the capabilities of the
  procedure performing this system call.
\end{itemize}

There are two highly critical functions here upon which the safety of the kernel
relies. The first is the validation of the procedure bytecode, which is covered
in Section~\ref{bytecode-validation}, but it is also necessary to ensure that
the capabilities that are being asked to be given to the new procedure can be
provided by the current procedure. In order to satisfy this constraint it must
be shown that for every requested procedure, there exists a capability in the
capability list of the current procedure. It is currently not able to
``combine'' capabilities. That is, if the procedure has a capability of
Write(0x80,5) and Write(0x85,5) it cannot provide a capability Write(0x80,10)
even though it theoretically still able to perform the same writes (TODO: this
is an interesting topic for consideration).

The algorithm is as follows:

\begin{enumerate}
  \item For each of the capabilities in the list of requested capabilities,
  search though the list of the current procedures capabilities until a superset
  of the requested capability is found.
  \item If for any of the requested capabilities a superset is not found, abort
  the entire process.
  \item If for all of the requested capabilities a superset is found, register
  the capability.
\end{enumerate}

\subsubsection{Error Codes}
If the Register Procedure system call fails for any reason other than those
general system call failure conditions, the system call will return
\texttt{SYSCALL\_FAIL} (as definted in Section~\ref{errors}) followed by one of
the following codes.

\begin{table}[H]
  \caption{Return and error codes.}
  \centering{}%
  \begin{tabular}{l|l|p{0.2\textwidth}|p{0.2\textwidth}}
    \hline
    Type & Value & Additional Data & Description\tabularnewline
    \hline
    \hline
    REG\_TOOMANYCAPS  & 77 & None & Too many caps were provided. \tabularnewline
    \hline
  \end{tabular}
\end{table}

\marginpar[Non-Normative]{\textbf{Non-Normative}}For example, if the Register
Procedure system call was executed but provides too many capabilities then the
DELEGATECALL will leave a 0 on the stack and return two bytes (\texttt{0x6677}).

\subsection{Delete Procedure System Call}

\subsubsection{System Call Format}
Type Value: 5

Data: min(64 bytes) max(64 bytes)

\begin{table}[H]
  \caption{Delete procedure system call.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Procedure key; 24 bytes in 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Format}
The capability format for the Delete Procedure system call is trivial as it
contains not data. Its presence alone is enough to confer the ability to set the
entry procedure. This means it is always exactly 0x0105. TODO: this is because
it can delete any procedure, which is likely to change in the future.

\begin{table}[H]
  \caption{Delete procedure capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x05 & The type of the capability \tabularnewline
    0x2 & -    & The prefix and base procedure key, the first byte is the prefix
                 size which is in the interval [0,24], bytes [0x1,0x7] are
                 unused and undefined, bytes [0x8,0x32] are the 24 bytes of the
                 base procedure key. \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\includegraphics[width=\textwidth]{media/ProcedureKeyBytes.pdf}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets. For the delete procedure capability a subset is capability which
possesses the ability to delete no more procedures than the original.

The prefix size of a capability $C$ is given as $C_s$ and the base procedure key
$C_b$. Given a delete procedure capability $A$ and a proposed subset $B$:
\begin{itemize}
  \item If the prefix size of $B$ is equal to or greater than $A$ (that is: $B_s
  \geq A_s$), and
  \item If the first $B_s$ bits of $B_b$ is equal to the first $A_s$ bits of
  $A_b$.
\end{itemize}

\subsection{Set Entry Procedure System Call}
The value of the Entry Procedure is 24-byte procedure key which identified which
procedure should be first called upon receiving a transaction. This is currently
store at the storage location:

0x00ac949d7c2a616cb3ec3ee17eff195232626e4026e3430fb3ce7b4d69e6fb1c

Which is keccack256("entryProcedure") with the first byte set to 0x00 to place
the key within kernel-storage.

\subsubsection{Error Codes}
If the Delete Procedure system call fails for any reason other than those
general system call failure conditions, the system call will return
\texttt{SYSCALL\_FAIL} (as definted in Section~\ref{errors}) followed by one of
the following codes.

\begin{table}[H]
  \caption{Return and error codes.}
  \centering{}%
  \begin{tabular}{l|l|p{0.2\textwidth}|p{0.2\textwidth}}
    \hline
    Type & Value & Additional Data & Description\tabularnewline
    \hline
    \hline
    DEL\_NOPROC  & 33 & None & The procedure key specified does not exit.
      \tabularnewline
    \hline
  \end{tabular}
\end{table}

\marginpar[Non-Normative]{\textbf{Non-Normative}}For example, if the Delete
Procedure system call was executed with a procedure key that does not exist then
the DELEGATECALL will leave a 0 on the stack and return two bytes
(\texttt{0x6633}).

\subsubsection{System Call Format}

Type Value: 6

Data: min(64 bytes) max(64 bytes)

\begin{table}[H]
  \caption{Set entry procedure system call format.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Procedure key; 24 bytes in 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Format}
The capability format for the Set Entry Procedure system call is trivial as it
contains not data. Its presence alone is enough to confer the ability to set the
entry procedure. This means it is always exactly 0x0106.

\begin{table}[H]
  \caption{Set entry procedure capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x06 & The type of the capability \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets. As the Set Entry Procedure capability is a trivial value, there is
only one value for Set Entry Procedure capabilities and they are all equal.

Given a Set Entry Procedure capability $A$ and any other Set Entry Procedure
capability $B$, not only is $B \subseteq A$ but also $B = A$.

\subsubsection{Function}
The only possible state change is the "entryProcedure" value. TODO: we must
define this location. No other state changes should occur.

\subsubsection{Error Codes}
If the Set Entry Procedure system call fails for any reason other than those
general system call failure conditions, the system call will return
\texttt{SYSCALL\_FAIL} (as definted in Section~\ref{errors}) followed by one of
the following codes.

\begin{table}[H]
  \caption{Return and error codes.}
  \centering{}%
  \begin{tabular}{l|l|p{0.2\textwidth}|p{0.2\textwidth}}
    \hline
    Type & Value & Additional Data & Description\tabularnewline
    \hline
    \hline
    SETENT\_NOPROC  & 33 & None & The procedure key specified does not exit.
      \tabularnewline
    \hline
  \end{tabular}
\end{table}

\marginpar[Non-Normative]{\textbf{Non-Normative}}For example, if the Set Entry Procedure system call was executed with a
procedure key that does not exist then the DELEGATECALL will leave a 0 on the
stack and return two bytes (\texttt{0x6633}).

\subsection{Store System Call}

\subsubsection{System Call Format}
Type Value: 7

Data:

\begin{table}[H]
  \caption{System call structure.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Write address; 32 bytes \tabularnewline
    0x40 & Write values; 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Store Capability Format}
The store capability includes 2 values: the first is the base address where we
can write to storage. The second is the number of \emph{additional} addresses we
can write to. For example, if the first value is 0x8000, and the second value is
0, we can write only to location 0x8000. If the second value was 5, we could
write to 0x8000, 0x8000+1, 0x8000+2, 0x8000+3, 0x8000+4, and 0x8000+5.

\begin{table}[H]
  \caption{Store capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x03 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x07 & The type of the capability \tabularnewline
    0x1 & $a$ & The base storage address\tabularnewline
    0x3 & $n$ & The number of additional keys we can write to\tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets.

Given a Store capability $A$ and a proposed subset $B$, where $C_a$ is the base
address of capability $C$ and $C_n$ is the number of additional keys writable
with capability $C$, $B \subseteq A \iff \left(B_a \geq A_a\right) \land
\left(B_a + B_n \leq A_a + A_n\right)$.

Or more verbosely, $B$ is only a subset of $A$ if and only if:
\begin{itemize}
  \item The lowest writable address (which is the base address) of $B$ is
  greater than or equal to the lowest writable address of $A$, and
  \item The highest writable address (which is base address plus the number of
  additional keys) of $B$ is less than or equal to the highest writable address
  of $A$.
\end{itemize}

\subsubsection{Error Codes}
There are no specific error conditions for SSTORE, therefore only general system
call errors are applicable.

\subsection{Log System Call}

\subsubsection{System Call Format}
Type Value: 8

Data: min(96 bytes) max(224 bytes)

\begin{table}[H]
  \caption{System call structure.}
  \centering{}%
  \begin{tabular}{l|p{0.6\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Number of topics (nTopics) \tabularnewline
    ... & Potentially topic value \#1; 32 bytes \tabularnewline
    ... & Potentially topic value \#2; 32 bytes \tabularnewline
    ... & Potentially topic value \#3; 32 bytes \tabularnewline
    ... & Potentially topic value \#4; 32 bytes \tabularnewline
    0x40+(nTopics x 0x20) & Log value 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Format}
The store capability includes between 0 and 4 values. Each value forces the use
of a particular value. For example: if the capability has 1 value, then that
means that the first topic in the log call must equal that. If it has 2 values
then the first log topic must be the first of those values and the second topic
must be the second of those values and so on. If there are no topics listed then
there are no restrictions on what can be logged.

\begin{table}[H]
  \caption{Log capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & [0x01, 0x5] & Capability size; 32 bytes \tabularnewline
    0x1 & 0x08 & The type of the capability \tabularnewline
    0x2 & $t_1$ & Potentially an enforced value for the first topic
      \tabularnewline
    0x3 & $t_2$ & Potentially an enforced value for the second topic
      \tabularnewline
    0x4 & $t_3$ & Potentially an enforced value for the third topic
      \tabularnewline
    0x5 & $t_4$ & Potentially an enforced value for the fourth topic
      \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets.

Given a Log capability $A$ and a proposed subset $B$, $B \subseteq A$ if and
only if for each log topic of $A$ the topic is either undefined or equal to that
of $B$.

If $C_{t_i}$, where $i$ is $1$, $2$, $3$, or $4$, is the log topic $i$ of
capability $C$, and $C_n$ is the number of defined topics:

$$ \forall i \in \left\{1,2,\dots ,A_n\right\}. B_{t_i} = A_{t_i} $$

\subsubsection{Error Codes}
There are no specific error conditions for SSTORE, therefore only general system
call errors are applicable.

\subsection{Value Send System Call}
This system call sends value (Ether) to another account.

\subsubsection{System Call Format}
Type Value: 9

Data:

\begin{table}[H]
  \caption{System call structure.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Account address; 20-bytes right aligned in 32 bytes \tabularnewline
    0x40 & Value amount; 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Value Send Capability Format}
The value send capability does not include any values, and therefore is just a
constant 0x0109.

\begin{table}[H]
  \caption{Value send capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x09 & The type of the capability \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets. As the Value Send capability is a trivial value, there is only one
value for Value Send capabilities and they are all equal.

Given a Value Send capability $A$ and any other Value Send capability $B$, not
only is $B \subseteq A$ but also $B = A$.

\section{Procedure Bytecode Validation}\label{bytecode-validation}
In order to pass bytecode validation each opcode in the contract must either be
on the whitelist, or part of a recognised system call. The whitelist comprises
all non-state-changing opcodes, and a system call is in the form:

\definecolor{mygreen}{rgb}{0,0.6,0}
\begin{minipage}{\linewidth}
\begin{lstlisting}[language=c,commentstyle=\color{mygreen},basicstyle=\ttfamily,
  identifierstyle=\color{blue},
  caption=Sequence of steps to perform a system call.]
CALLER       // Get Caller
GAS          // Put all the available gas on the stack
DELEGATECALL // Delegate Call to Caller
\end{lstlisting}
\end{minipage}

\end{document}
