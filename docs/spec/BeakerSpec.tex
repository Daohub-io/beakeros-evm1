\documentclass[english,a4paper]{article}
\usepackage{lmodern}
\usepackage{float}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}

\usepackage{microtype}
\usepackage[unicode=true]{hyperref}
\usepackage[usenames,dvipsnames]{color}
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={},
            pdftitle={},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            %linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{listings}

\usepackage{longtable,booktabs}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines


% Redefines (sub)paragraphs to behave more like sections
\ifx\subsubsection\undefined\else
\let\oldparagraph\subsubsection
\renewcommand{\subsubsection}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\title{Beaker Specification}\label{beaker-specification}

\author{Jacob Payne \and Jake O'Shannessy \and Alexey Troitskiy}

\begin{document}

\maketitle

\begin{abstract}\label{abstract}

We describe a secure and extensible operating system for smart contracts. Using
a capability-based exokernel protocol, we can facilitate secure isolation,
perform upgrades in a secure and robust manner, and prevent privilege escalation
at any point in the development process. The protocol is intended to serve as an
open standard and building block upon which more advanced and tailored security
models can be built.

\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Procedures}\label{procedures}
Procedure data is stored under the key 0xd8dd4195f87d. The storage page (in this
case kernel storage) is prepended to this, and the procedure key is appended to
this, resulting in:

\begin{verbatim}
  0x00d8dd4195f87d + 24 bytes procedure key
\end{verbatim}

There is currently not mechanism by which procedures are prevented from
overlapping.

I propose to remove 1 byte from 0xd8dd4195f87d, reducing to 5 bytes
(0xd8dd4195f8). This leaves a full byte at the least significant end. This
guarantees a 256 storage values for each procedure, or maybe 2 bytes for 65,535
values, which is an enormous amount. This will guarantee a certain space for
each procedure.

\begin{table}[H]
  \caption{Procedure table.}
  \centering{}%
  % \begin{tabular}{>{\centering}p{0.25\textwidth}|>{\centering}p{0.475\textwidth}|>{\centering}p{0.2\textwidth}}
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Key Offset & Description\tabularnewline
    \hline
    \hline
    0x0       & key: 24 bytes, aligned right in the 32 bytes, the given
      name \tabularnewline
    0x1       & keyIndex: ?? bytes, aligned right in the 32 bytes
      \tabularnewline
    0x2       & address: 20 bytes, aligned right in the 32 bytes \tabularnewline
    0x3       & numCaps: ?? bytes, aligned right in the 32 bytes \tabularnewline
    0x4\ldots & capabilities in series \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsection{Operations on Procedure Table}
This only considers state-changing operations:

\begin{enumerate}
  \item addProcedure
  \item removeProcedure
\end{enumerate}

\subsubsection{addProcedure}
\begin{itemize}
  \item Will increment the number procedures.
  \item Will update the keyIndex value to the new key. TODO: specify this.
  \item Will store the procedure at the location determined by its key.
\end{itemize}

\subsubsection{removeProcedure}
\begin{itemize}
  \item \emph{May} zero out the storage location of the procedure data,
  depending on efficiency.
  \item Will decrement the number of procedures.
  \item Will move the procedure in the last position to the keyIndex of the
  procedure just deleted.
  \item Will throw an error if it attempts to delete the entry proc.
\end{itemize}

THis all assumes that caps are registered together.

\section{Capabilities}\label{capabilities}
\begin{table}[H]
  \caption{Capability.}
  \centering{}%
  % \begin{tabular}{>{\centering}p{0.25\textwidth}|>{\centering}p{0.475\textwidth}|>{\centering}p{0.2\textwidth}}
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Key Offset & Description\tabularnewline
    \hline
    \hline
    0x0       & CapSize: ?? bytes, aligned right in the 32 bytes, the given
      name \tabularnewline
    0x1       & CapType: 1 byte, aligned right in the 32 bytes \tabularnewline
    0x2       & key value \#1: 32 bytes \tabularnewline
    ~~~$\vdots$ & capabilities in series \tabularnewline
    CapSize & final key value \tabularnewline
    \hline
  \end{tabular}
\end{table}

\section{Kernel Storage}\label{kernel-storage}
This is a critical feature. \emph{All} data stored by the kernel is stored in a
region of \emph{storage} called \emph{kernel storage}. \emph{No} other data can
be stored in \emph{kernel storage}.

This kernel storage is defined as all storage locations within a certain storage
range. All values in kernel storage share the same storage key prefix. This
prefix is currently 0x00, and so currently includes all values in the interval
$[0\text{x}0000 \cdots 0000, 0\text{x}0100 \cdots 0000)$ (some zeros have been
elided for typographic reasons, but each values is 32 bytes).

Note: This is currently defined using storage pages which we don't use anywhere
else.

\subsection{Procedure Table}\label{procedure-table}
This defines the table that locates all of the procedures.

The procedure table is stored of x = bytes8(keccack256("keyPointer")) = 64 bits
= 0x-5b-ac-19-8c-37-7b-92. This is shifted to only take the last byte (0x92).
Along with the storage page this creates a prefix of ${0\text{x} 00 92 \cdots}$.
We probably don't need to shift this much as it gives us an enormous amount of
space.

\begin{verbatim}
  0x 00 92 + 28 more bytes
\end{verbatim}

keyIndices start at 1 therefore 0x0092+1 is always undefined.

The procedure table does not actually contain of the procedure data, simply a
list of keys (procedure names). Data for each procedure is found elsewhere.

\begin{table}[H]
  \caption{Procedure table.}
  \centering{}%
  \begin{tabular}{l|p{0.6\textwidth}}
    \hline
    Storage Location & Description\tabularnewline
    \hline
    \hline
    0x0092     & length/number of procedures \tabularnewline
    0x0092 + 1 & undefined (as keyIndex is never 0) \tabularnewline
    0x0092 + 1 + keyIndex & procedure key/name: 24 bytes \tabularnewline
    ~~~$\vdots$ & capabilities in series \tabularnewline
    0x0092 + 1 + n & procedure key/name for procedure $n$ \tabularnewline
    \hline
  \end{tabular}
\end{table}

\section{System Calls and Capabilities}
All system calls are transactions to the kernel. The transaction data is defined
as follows:

\begin{table}[H]
  \caption{System call structure.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & 1 byte, system call value \tabularnewline
    0x8 & The system call data as defined by each system call \tabularnewline
    ~~~$\vdots$ &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

System call numbers match capability numbers.

\begin{table}[H]
  \caption{System call and capability numbers.\label{syscall-numbers}}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Type Value & Description\tabularnewline
    \hline
    \hline
    0x0 & Null capability / noop \tabularnewline
    % 0x1 & The system call data as defined by each system call \tabularnewline
    % 0x2 & The system call data as defined by each system call \tabularnewline
    0x3 & Call Procedure \tabularnewline
    0x4 & Register Procedure \tabularnewline
    0x5 & Delete Procedure \tabularnewline
    0x6 & Set Entry Procedure \tabularnewline
    0x7 & Write \tabularnewline
    0x8 & Log \tabularnewline
    0x9 & Gas Send \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsection{Executing a System Call}
The running code will issue a transaction to the kernel by perfoming a
DELEGATECALL to the kernel with the transactions message data as both above and
in the definitons of each capability. The system call will be processed as
follows:

\begin{enumerate}
  \item The kernel will receive the transaction as defined by the EVM.
  \item The kernel will read the first byte of the transaction data as an
  unsigned 8-bit integer. This value is $s$.
  \item If $s$ is not one of the values listed in Table
  \ref{syscall-numbers} then the kernel will revert the current transaction
  (i.e. the DELEGATECALL) and return an appropriate errorcode (TODO: define the
  error code).
  \item If $s$ is 0, it will do nothing and return successfully.
  \item Otherwise the control will be passed to the code in the kernel
  corresponding to the $s$. For example if the $s = 0x4$, then the code for
  executing a Register Procedure syscall will be called.
  \item This code will execute and return whatever value it deems appropriate.
\end{enumerate}

\subsection{Capability Subsets}\label{cap-subsets}

Capability $B$ is a subset\footnote{$A$ subset, not a \emph{strict} or
\emph{proper} subset.} of Capability $A$, if everything that can be done using
Capability $B$ can be done using Capabilty $A$. The following rules apply:

\begin{itemize}
  \item $A$ is always a subset of itself. $A \subseteq A$
  \item Transitivity: $A \subseteq B \land B \subseteq C \implies A
  \subseteq C$
\end{itemize}

As the nature of each capability is different, the way subsets are defined is
different for each one. The following sections will define how subsets are
defined for each capability.

\subsection{Call System Call}

\subsubsection{System Call Format}
Type Value: 3

Data: Note that here the offset is from after system call type.

\begin{table}[H]
  \caption{Call procedure system call format.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Procedure key, 24 bytes in 32 bytes (which alignment) \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Format}
The capability format for the Call Procedure sysem call can be split into two
categories: call-any and call-list. If the capability is call-any, then the
capability does not contain any additional data and it is simply the value of
the call capability type. In this case the capability would be 0x103.
Alternatively the capability can be restricted to call one of a list of
procedure names.

In the table below $n$ is the length of the list of procedure names that can be
called.

\begin{table}[H]
  \caption{Call procedure capability format where $n = 0$.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x03 & The type of the capability \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\begin{table}[H]
  \caption{Call procedure capability format where $n \geq 1$.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01+$n$ & Capability size; 32 bytes \tabularnewline
    0x1 & 0x03 & The type of the capability \tabularnewline
    0x1 + 1 & $p_1$ & First callable procedure name \tabularnewline
    ~~~$\vdots$ & $p_i$ & Other procedure names \tabularnewline
    0x1 + $n$ & $p_n$ & Last callable procedure name \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets. For the call capability a subset is capability which possesses the
ability to call no more procedures than the original.

Given a call procecedure capability $A$ and a proposed subset $B$:
\begin{itemize}
  \item If the capability has no procedure names listed ($n=0$), then the $B$ is
  a subset if and only if $B$ also has no procedure names listed ($n=0$).
  \item If the capability has a list of procedure names, $B \subseteq A$ if and
  only if all of the values/procedure names listed in $B$ are also listed in
  $A$. Ordering of the procedure names is not relevant.
\end{itemize}

\subsection{Register Procedure System Call}

\subsubsection{System Call Format}
Type Value: 4

Data: min(96 bytes) max(96 bytes)

\begin{table}[H]
  \caption{System call structure.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Procedure key; 24 bytes in 32 bytes \tabularnewline
    0x40 & Procedure address; 20 bytes in 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}
TODO: update this to register capabilities as well.

\subsubsection{Capability Format}
The capability format for the Register Procedure system call is trivial as it
contains not data. Its presence alone is enough to confer the ability to set the
entry procedure. This means it is always exactly 0x0104.

\textbf{NB:} Register procedure also relies on all of the other capabilities
possessed by a procedure to determine what capabilities the new procedure will
have.

\begin{table}[H]
  \caption{Register procedure capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x04 & The type of the capability \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets. As the Register Procedure capability is a trivial value, there is
only one value for Register Procedure capabilities and they are all equal.

Given a Register Procedure capability $A$ and any other Register Procedure
capability $B$, not only is $B \subseteq A$ but also $B = A$.

\subsection{Delete Procedure System Call}

\subsubsection{System Call Format}
Type Value: 5

Data: min(64 bytes) max(64 bytes)

\begin{table}[H]
  \caption{Delete procedure system call.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Procedure key; 24 bytes in 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Format}
The capability format for the Delete Procedure system call is trivial as it
contains not data. Its presence alone is enough to confer the ability to set the
entry procedure. This means it is always exactly 0x0105. TODO: this is because
it can delete any procedure, which is likely to change in the future.

\begin{table}[H]
  \caption{Delete procedure capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x05 & The type of the capability \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets. As the Delete Procedure capability is a trivial value, there is only
one value for Delete Procedure capabilities and they are all equal.

Given a Delete Procecedure capability $A$ and any other Delete Procedure
capability $B$, not only is $B \subseteq A$ but also $B = A$.

Note: If this is changed to include a list of procedures that can be deleted,
this will need to be updated to more closely reflect the Call Procedure
capability's definition of subsets.

\subsection{Set Entry Procedure System Call}
TODO: this is currently non-compliant as it is not stored in the kernel.

\subsubsection{System Call Format}

Type Value: 6

Data: min(64 bytes) max(64 bytes)

\begin{table}[H]
  \caption{Set entry procedure system call format.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Procedure key; 24 bytes in 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Format}
The capability format for the Set Entry Procedure system call is trivial as it
contains not data. Its presence alone is enough to confer the ability to set the
entry procedure. This means it is always exactly 0x0106.

\begin{table}[H]
  \caption{Set entry procedure capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x01 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x06 & The type of the capability \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{What happens?}
The only possible state change is the "entryProcedure" value. TODO: we must
define this location. No other state changes should occur.

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets. As the Set Entry Procecedure capability is a trivial value, there is
only one value for Set Entry Procecedure capabilities and they are all equal.

Given a Set Entry Procecedure capability $A$ and any other Set Entry Procecedure
capability $B$, not only is $B \subseteq A$ but also $B = A$.

\subsection{Store System Call}

\subsubsection{System Call Format}
Type Value: 7

Data:

\begin{table}[H]
  \caption{System call structure.}
  \centering{}%
  \begin{tabular}{l|p{0.7\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Write address; 32 bytes \tabularnewline
    0x40 & Write values; 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Store Capability Format}
The store capability includes 2 values: the first is the base address where we
can write to storage. The second is the number of \emph{additional} addresses we
can write to. For example, if the first value is 0x8000, and the second value is
0, we can write only to location 0x8000. If the second value was 5, we could
write to 0x8000, 0x8000+1, 0x8000+2, 0x8000+3, 0x8000+4, and 0x8000+5.

\begin{table}[H]
  \caption{Store capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & 0x03 & Capability size; 32 bytes \tabularnewline
    0x1 & 0x07 & The type of the capability \tabularnewline
    0x1 & $a$ & The base storage address\tabularnewline
    0x3 & $n$ & The number of additional keys we can write to\tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets.

Given a Store capability $A$ and a proposed subset $B$, where $C_a$ is the base
address of capability $C$ and $C_n$ is the number of additional keys writable
with capability $C$, $B \subseteq A \iff \left(B_a \geq A_a\right) \land
\left(B_a + B_n \leq A_a + A_n\right)$.

Or more verbosely, $B$ is only a subset of $A$ if and only if:
\begin{itemize}
  \item The lowest writable address (which is the base address) of $B$ is
  greater than or equal to the lowest writable address of $A$, and
  \item The highest writable address (which is base address plus the number of
  additional keys) of $B$ is less than or equal to the highest writable address
  of $A$.
\end{itemize}

\subsection{Log System Call}

\subsubsection{System Call Format}
Type Value: 8

Data: min(96 bytes) max(224 bytes)

\begin{table}[H]
  \caption{System call structure.}
  \centering{}%
  \begin{tabular}{l|p{0.6\textwidth}}
    \hline
    Byte Offset & Description\tabularnewline
    \hline
    \hline
    0x0 & Capability index; 32 bytes \tabularnewline
    0x20 & Number of topics (nTopics) \tabularnewline
    ... & Potentially topic value \#1; 32 bytes \tabularnewline
    ... & Potentially topic value \#2; 32 bytes \tabularnewline
    ... & Potentially topic value \#3; 32 bytes \tabularnewline
    ... & Potentially topic value \#4; 32 bytes \tabularnewline
    0x40+(nTopics x 0x20) & Log value 32 bytes \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Format}
The store capability includes between 0 and 4 values. Each value forces the use
of a particular value. For example: if the capability has 1 value, then that
means that the first topic in the log call must equal that. If it has 2 values
then the first log topic must be the first of those values and the second topic
must be the second of those values and so on. If there are no topics listed then
there are no restrictions on what can be logged.

\begin{table}[H]
  \caption{Log capability format.}
  \centering{}%
  \begin{tabular}{l|l|p{0.5\textwidth}}
    \hline
    Key Offset & Value & Description\tabularnewline
    \hline
    \hline
    0x0 & [0x01, 0x5] & Capability size; 32 bytes \tabularnewline
    0x1 & 0x08 & The type of the capability \tabularnewline
    0x2 & $t_1$ & Potentially an enforced value for the first topic
      \tabularnewline
    0x3 & $t_2$ & Potentially an enforced value for the second topic
      \tabularnewline
    0x4 & $t_3$ & Potentially an enforced value for the third topic
      \tabularnewline
    0x5 & $t_4$ & Potentially an enforced value for the fourth topic
      \tabularnewline
    \hline
    End &  \tabularnewline
    \hline
  \end{tabular}
\end{table}

\subsubsection{Capability Subsets}
As defined in Section~\ref{cap-subsets}, each capability has subsets and
supersets.

Given a Log capability $A$ and a proposed subset $B$, $B \subseteq A$ if and
only if for each log topic of $A$ the topic is either undefined or equal to that
of $B$.

If $C_{t_i}$, where $i$ is $1$, $2$, $3$, or $4$, is the log topic $i$ of
capability $C$, and $C_n$ is the number of defined topics:

$$ \forall i \in \left\{1,2,\dots ,A_n\right\}. B_{t_i} = A_{t_i} $$

\section{Return and Error Codes}
This section defines return and error codes where they are needed.

\begin{table}[H]
  \caption{Return and error codes.}
  \centering{}%
  \begin{tabular}{l|l|p{0.4\textwidth}}
    \hline
    Type & Value & Description\tabularnewline
    \hline
    \hline
    SYSCALL\_SUCCESS      & 0 & Syscall was executed successfully\tabularnewline
    SYSCALL\_READ\_ERR    & 11 & ?? \tabularnewline
    SYSCALL\_WRITE\_ERR   & 22 & ?? \tabularnewline
    SYSCALL\_LOG\_ERR     & 33 & ?? \tabularnewline
    SYSCALL\_CALL\_ERR    & 44 & ?? \tabularnewline
    NO\_SUCH\_SYSCALL\_ERR & 111 & The syscall integer values is not a valid
      syscall as defined in Table \ref{syscall-numbers} \tabularnewline
    \hline
  \end{tabular}
\end{table}

\end{document}
